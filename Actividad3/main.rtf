{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue0;\red255\green255\blue255;\red200\green200\blue200;\red0\green0\blue0;\red152\green152\blue217;\red192\green192\blue192;\red128\green128\blue255;\red170\green170\blue240;\red0\green128\blue128;\red107\green153\blue153;\red128\green0\blue0;\red172\green89\blue89;\red240\green0\blue240;\red240\green200\blue240;\red0\green0\blue160;\red135\green135\blue200;\red0\green160\blue0;\red154\green200\blue154;\red190\green0\blue190;\red190\green137\blue190;\red0\green0\blue255;\red190\green190\blue255;\red224\green160\blue0;\red224\green206\blue159;\red132\green160\blue132;\red255\green0\blue0;\red255\green200\blue200;\red64\green64\blue128;\red133\green133\blue172;\red128\green255\blue255;\red55\green55\blue55;}
{\info{\comment Generated by the Code::Blocks RTF Exporter plugin}
{\title Untitled}}

\deflang1033\pard\plain\f0\fs20 \cb3\cf4 /*
\par Alumno: Padilla Perez Jorge Daray
\par Codigo: 216584703
\par Materia: Estructura de datos 2
\par seccion: D09
\par Profesor: Miguel Angel Guerrero Segura Ramirez
\par */
\par \cb3\cf16 #include "../extras/Arches.h"
\par #include "../extras/Tomarc.h"
\par #define campo_a_buffreg(br,cad) strcat(br,cad); strcat(br,DELIM_CAD);
\par 
\par \cb3\cf4 //seccion de prototipos de funciones.
\par \cb3\cf14\b void \b0\cb1\cf0 menu\cb3\cf25 ();
\par \cb3\cf14\b void \b0\cb1\cf0 escriberreg\cb3\cf25 ();
\par \cb3\cf14\b void \b0\cb1\cf0 leerreg\cb3\cf25 ();
\par 
\par \cb3\cf4 //seccion de variables
\par     \cb3\cf14\b char \b0\cb1\cf0 respuesta\cb3\cf25 [\cb3\cf12 50\cb3\cf25 ];
\par     \cb3\cf14\b char \b0\cb1\cf0 nomarch\cb3\cf25 [\cb3\cf12 15\cb3\cf25 ];
\par     \cb3\cf14\b int \b0\cb1\cf0 fd\cb3\cf25 , \cb1\cf0 cont_reg\cb3\cf25 , \cb1\cf0 cont_campos\cb3\cf25 , \cb1\cf0 i\cb3\cf25 ;
\par     \cb3\cf14\b int \b0\cb1\cf0 pos_bus\cb3\cf25 , \cb1\cf0 long_reg\cb3\cf25 ;
\par     \cb3\cf14\b char \b0\cb1\cf0 campo\cb3\cf25 [\cb1\cf0 TAM_MAX_REG \cb3\cf25 + \cb3\cf12 1\cb3\cf25 ];
\par     \cb3\cf14\b char \b0\cb1\cf0 buffreg\cb3\cf25 [\cb1\cf0 TAM_MAX_REG \cb3\cf25 + \cb3\cf12 1\cb3\cf25 ];
\par \cb3\cf14\b char \b0\cb3\cf25 *\cb1\cf0 solicitud\cb3\cf25 [] = \{\cb3\cf4 //Matriz de punteros. arreglo de apuntadores a caracter.
\par  \cb3\cf20 " Titulo de pelicula: o <CR> para salir:"\cb3\cf25 ,
\par  \cb3\cf20 "                          protagonista: "\cb3\cf25 ,
\par  \cb3\cf20 "                              director: "\cb3\cf25 ,
\par  \cb3\cf20 "              Estudio, o distribuidora: "\cb3\cf25 ,
\par  \cb3\cf20 "                                genero: "\cb3\cf25 ,
\par  \cb3\cf20 "                        a√±o de estreno: "\cb3\cf25 ,
\par  \cb3\cf20 "           numero de premios obtenidos: "\cb3\cf25 ,
\par  \cb3\cf20 "      calificacion otorgada a la cinta: "\cb3\cf25 ,
\par  \cb3\cf20 ""  \cb3\cf4 //cadena nula para terminar la solicitud
\par \cb3\cf25 \};
\par 
\par \cb3\cf14\b int \b0\cb1\cf0 main\cb3\cf25 ()
\par \{
\par     \cb3\cf14\b int \b0\cb1\cf0 opc \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ;
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "Proporcione el nombre del archivo que quiera crear o leer: "\cb3\cf25 );
\par     \cb1\cf0 gets \cb3\cf25 (\cb1\cf0 nomarch\cb3\cf25 );\cb3\cf4 //Obtencion del nombre del archivo fisico.
\par     \cb3\cf14\b if \b0\cb3\cf25 ((\cb1\cf0 fd \cb3\cf25 = \cb1\cf0 open\cb3\cf25 (\cb1\cf0 nomarch\cb3\cf25 ,\cb1\cf0 LECTESCRIT\cb3\cf25 )) < \cb3\cf12 0\cb3\cf25 )\cb3\cf4 //Apertura de archivo fisico, a traves del archivo logico. Escritura y Lectura.
\par     \cb3\cf25 \{
\par         \cb1\cf0 fd \cb3\cf25 = \cb1\cf0 creat\cb3\cf25 (\cb1\cf0 nomarch\cb3\cf25 ,\cb1\cf0 PMODE\cb3\cf25 );\cb3\cf4 //Creacion del archivo fisico, a traves del archivo logico. En PMODE 0755.
\par         \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "Creado correctamente\\n"\cb3\cf25 );
\par         \cb1\cf0 system\cb3\cf25 (\cb3\cf20 "pause"\cb3\cf25 );
\par     \}
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "Abierto correctamente\\n"\cb3\cf25 );
\par     \cb1\cf0 system\cb3\cf25 (\cb3\cf20 "pause"\cb3\cf25 );
\par     \cb3\cf14\b while \b0\cb3\cf25 (\cb1\cf0 opc\cb3\cf25 !=\cb3\cf12 3\cb3\cf25 )
\par     \{
\par         \cb1\cf0 system\cb3\cf25 (\cb3\cf20 "cls"\cb3\cf25 );
\par         \cb1\cf0 menu\cb3\cf25 ();
\par         \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "Continuar 1 salir 3:\\n"\cb3\cf25 );\cb1\cf0 scanf\cb3\cf25 (\cb3\cf20 "%d"\cb3\cf25 , &\cb1\cf0 opc\cb3\cf25 );
\par    \}
\par     \cb3\cf14\b return \b0\cb3\cf12 0\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf4 //escribereg
\par \cb3\cf14\b void \b0\cb1\cf0 escriberreg\cb3\cf25 ()
\par \{
\par     \cb1\cf0 fflush\cb3\cf25 (\cb1\cf0 stdin\cb3\cf25 );
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\n\\n%s"\cb3\cf25 , \cb1\cf0 solicitud\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ]);
\par     \cb1\cf0 gets\cb3\cf25 (\cb1\cf0 respuesta\cb3\cf25 );
\par     \cb3\cf14\b while \b0\cb3\cf25 (\cb1\cf0 strlen\cb3\cf25 (\cb1\cf0 respuesta\cb3\cf25 ) > \cb3\cf12 0\cb3\cf25 )
\par     \{
\par         \cb1\cf0 fflush\cb3\cf25 (\cb1\cf0 stdin\cb3\cf25 );
\par         \cb1\cf0 buffreg\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ] = \cb3\cf22 '\\0'\cb3\cf25 ;
\par         \cb1\cf0 lseek\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 ,\cb3\cf12 0L\cb3\cf25 ,\cb3\cf12 2\cb3\cf25 );
\par         \cb1\cf0 campo_a_buffreg\cb3\cf25 (\cb1\cf0 buffreg\cb3\cf25 ,\cb1\cf0 respuesta\cb3\cf25 );
\par         \cb3\cf14\b for \b0\cb3\cf25 (\cb1\cf0 i\cb3\cf25 =\cb3\cf12 1\cb3\cf25 ; *\cb1\cf0 solicitud\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ] != \cb3\cf22 '\\0' \cb3\cf25 ; \cb1\cf0 i\cb3\cf25 ++)
\par         \{
\par             \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "%s"\cb3\cf25 , \cb1\cf0 solicitud\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]);
\par             \cb1\cf0 gets\cb3\cf25 (\cb1\cf0 respuesta\cb3\cf25 );
\par             \cb1\cf0 campo_a_buffreg\cb3\cf25 (\cb1\cf0 buffreg\cb3\cf25 ,\cb1\cf0 respuesta\cb3\cf25 );
\par         \}
\par 
\par     \cb3\cf4 //Escribe la longitud del registro y el contenido del buffer *
\par     \cb1\cf0 long_reg \cb3\cf25 = \cb1\cf0 strlen\cb3\cf25 (\cb1\cf0 buffreg\cb3\cf25 );
\par     \cb1\cf0 write\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 ,&\cb1\cf0 long_reg\cb3\cf25 ,\cb3\cf12 2\cb3\cf25 );
\par     \cb1\cf0 write\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 ,\cb1\cf0 buffreg\cb3\cf25 ,\cb1\cf0 long_reg\cb3\cf25 );
\par     \cb3\cf4 //Se prepara para los siguientes datos
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\n\\n%s"\cb3\cf25 , \cb1\cf0 solicitud\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ]);
\par     \cb1\cf0 gets\cb3\cf25 (\cb1\cf0 respuesta\cb3\cf25 );
\par     \}
\par \}
\par 
\par \cb3\cf4 //leereg
\par \cb3\cf14\b void \b0\cb1\cf0 leerreg\cb3\cf25 ()
\par \{
\par     \cb1\cf0 cont_reg \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ;
\par     \cb1\cf0 pos_bus \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ;
\par     \cb1\cf0 lseek\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 ,\cb3\cf12 0L\cb3\cf25 ,\cb3\cf12 0\cb3\cf25 );\cb3\cf4 //Traslada el puntero al inicio.
\par     \cb3\cf14\b while \b0\cb3\cf25 ((\cb1\cf0 long_reg \cb3\cf25 = \cb1\cf0 toma_reg\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 ,\cb1\cf0 buffreg\cb3\cf25 )) > \cb3\cf12 0\cb3\cf25 )
\par     \{
\par         \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "Registro %d\\n"\cb3\cf25 , ++\cb1\cf0 cont_reg\cb3\cf25 );
\par         \cb1\cf0 cont_campos \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ;
\par         \cb3\cf14\b while\b0\cb3\cf25 ((\cb1\cf0 pos_bus \cb3\cf25 = \cb1\cf0 toma_campo\cb3\cf25 (\cb1\cf0 campo\cb3\cf25 ,\cb1\cf0 buffreg\cb3\cf25 ,\cb1\cf0 pos_bus\cb3\cf25 ,\cb1\cf0 long_reg\cb3\cf25 )) > \cb3\cf12 0\cb3\cf25 )
\par         \{
\par             \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\tCampo %d: %s\\n"\cb3\cf25 , ++\cb1\cf0 cont_campos\cb3\cf25 , \cb1\cf0 campo\cb3\cf25 );
\par         \}
\par     \}
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 menu\cb3\cf25 ()
\par \{
\par     \cb3\cf14\b int \b0\cb1\cf0 opc \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ;
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "1) Ingresar pelicula\\n"\cb3\cf25 );
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "2) Leer pelicula\\n"\cb3\cf25 );
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "3) Salir\\n"\cb3\cf25 );
\par     \cb1\cf0 scanf\cb3\cf25 (\cb3\cf20 "%d"\cb3\cf25 , &\cb1\cf0 opc\cb3\cf25 );
\par     \cb3\cf14\b switch\b0\cb3\cf25 (\cb1\cf0 opc\cb3\cf25 )\{
\par 
\par         \cb3\cf14\b case \b0\cb3\cf12 1\cb3\cf25 : \{
\par                     \cb1\cf0 escriberreg\cb3\cf25 ();
\par                 \}\cb3\cf14\b break\b0\cb3\cf25 ;
\par         \cb3\cf14\b case \b0\cb3\cf12 2\cb3\cf25 : \{
\par                     \cb1\cf0 leerreg\cb3\cf25 ();
\par                 \}\cb3\cf14\b break\b0\cb3\cf25 ;
\par         \cb3\cf14\b case \b0\cb3\cf12 3\cb3\cf25 : \{
\par                     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "Saliendo\\n"\cb3\cf25 );
\par                      \cb1\cf0 close \cb3\cf25 (\cb1\cf0 fd\cb3\cf25 );\cb3\cf4 //Cierre del archivo.
\par                 \cb3\cf25 \}\cb3\cf14\b break\b0\cb3\cf25 ;
\par     \}
\par \}
\par 
\par }