{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue0;\red255\green255\blue255;\red200\green200\blue200;\red0\green0\blue0;\red152\green152\blue217;\red192\green192\blue192;\red128\green128\blue255;\red170\green170\blue240;\red0\green128\blue128;\red107\green153\blue153;\red128\green0\blue0;\red172\green89\blue89;\red240\green0\blue240;\red240\green200\blue240;\red0\green0\blue160;\red135\green135\blue200;\red0\green160\blue0;\red154\green200\blue154;\red190\green0\blue190;\red190\green137\blue190;\red0\green0\blue255;\red190\green190\blue255;\red224\green160\blue0;\red224\green206\blue159;\red132\green160\blue132;\red255\green0\blue0;\red255\green200\blue200;\red64\green64\blue128;\red133\green133\blue172;\red128\green255\blue255;\red55\green55\blue55;}
{\info{\comment Generated by the Code::Blocks RTF Exporter plugin}
{\title Untitled}}

\deflang1033\pard\plain\f0\fs20 \cb3\cf4 /*
\par Alumno: Padilla Perez Jorge Daray
\par Codigo: 216584703
\par Materia: Estructura de datos 2
\par seccion: D09
\par Profesor: Miguel Angel Guerrero Segura Ramirez
\par */
\par \cb3\cf16 #include "../extras/Arches.h"
\par #include "../extras/Tomarc.h"
\par #include "../extras/Funscads.h"
\par #define LONG_REG 64
\par #define campo_a_buffreg(br,cad) strcat(br,cad); strcat(br,DELIM_CAD);
\par #define campo_a_sin_deli(br,cad) strcat(br,cad);
\par 
\par \cb3\cf14\b static char \b0\cb3\cf25 *\cb1\cf0 solicitud\cb3\cf25 []=\{
\par     \cb3\cf20 "\\t Número de participación: "\cb3\cf25 ,
\par     \cb3\cf20 "\\t Tiempo de clasificación: [H:MM:SS]"\cb3\cf25 ,
\par     \cb3\cf20 "\\t Nombre de atleta: "\cb3\cf25 ,
\par     \cb3\cf20 "\\t Ciudad: "\cb3\cf25 ,
\par     \cb3\cf20 "\\t Nacionalidad: "\cb3\cf25 ,
\par     \cb3\cf20 "\\t Dirección del atleta: "\cb3\cf25 ,
\par     \cb3\cf20 ""
\par \cb3\cf25 \};
\par 
\par \cb3\cf14\b static int \b0\cb1\cf0 fd\cb3\cf25 ;
\par \cb3\cf14\b static struct
\par \b0\cb3\cf25 \{
\par     \cb3\cf14\b short \b0\cb1\cf0 cont_reg\cb3\cf25 ;
\par     \cb3\cf14\b char \b0\cb1\cf0 relleno\cb3\cf25 [\cb3\cf12 30\cb3\cf25 ];
\par \}\cb1\cf0 encabezado\cb3\cf25 ;
\par 
\par \cb3\cf14\b int \b0\cb1\cf0 main\cb3\cf25 ()
\par \{
\par     \cb3\cf14\b int \b0\cb1\cf0 i\cb3\cf25 , \cb1\cf0 menu_elec\cb3\cf25 , \cb1\cf0 nrr\cb3\cf25 ,\cb1\cf0 byte_pos\cb3\cf25 ;
\par     \cb3\cf14\b char \b0\cb1\cf0 nomarch\cb3\cf25 [\cb3\cf12 15\cb3\cf25 ];
\par     \cb3\cf14\b long \b0\cb1\cf0 lseek\cb3\cf25 ();
\par     \cb3\cf14\b char \b0\cb1\cf0 buffreg\cb3\cf25 [\cb1\cf0 TAM_MAX_REG \cb3\cf25 + \cb3\cf12 1\cb3\cf25 ];
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "Proporcione el nombre del archivo: "\cb3\cf25 );
\par     \cb1\cf0 gets\cb3\cf25 (\cb1\cf0 nomarch\cb3\cf25 );
\par 
\par     \cb3\cf14\b if\b0\cb3\cf25 ((\cb1\cf0 fd\cb3\cf25 =\cb1\cf0 open\cb3\cf25 (\cb1\cf0 nomarch\cb3\cf25 ,\cb1\cf0 LECTESCRIT\cb3\cf25 ))<\cb3\cf12 0\cb3\cf25 )
\par     \{
\par         \cb1\cf0 fd\cb3\cf25 =\cb1\cf0 creat\cb3\cf25 (\cb1\cf0 nomarch\cb3\cf25 ,\cb1\cf0 PMODE\cb3\cf25 );\cb3\cf4 //si no existe, lo crea
\par         \cb1\cf0 encabezado\cb3\cf25 .\cb1\cf0 cont_reg \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ; \cb3\cf4 //inicializa el encabezado
\par         \cb1\cf0 write\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 , &\cb1\cf0 encabezado\cb3\cf25 ,\cb3\cf14\b sizeof\b0\cb3\cf25 (\cb1\cf0 encabezado\cb3\cf25 ));\cb3\cf4 //escribe el registro del encabezado
\par     \cb3\cf25 \}
\par     \cb3\cf14\b else \b0\cb3\cf4 // se abre el archivo existente y lee el encabezado
\par     \cb3\cf25 \{
\par         \cb1\cf0 read\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 ,&\cb1\cf0 encabezado\cb3\cf25 ,\cb3\cf14\b sizeof\b0\cb3\cf25 (\cb1\cf0 encabezado\cb3\cf25 ));
\par     \}
\par     \cb3\cf4 //ciclo del programa principal llama al menu y salta las opciones
\par     \cb3\cf14\b while\b0\cb3\cf25 ((\cb1\cf0 menu_elec \cb3\cf25 = \cb1\cf0 menu\cb3\cf25 ()) < \cb3\cf12 3\cb3\cf25 )
\par     \{
\par         \cb3\cf14\b switch\b0\cb3\cf25 (\cb1\cf0 menu_elec\cb3\cf25 )
\par         \{
\par         \cb3\cf14\b case \b0\cb3\cf12 1\cb3\cf25 : \cb3\cf4 //agrega un registro nuevo
\par             \cb3\cf25 \{
\par                 \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "Proporcione la informacion del registro nuevo: \\n\\n"\cb3\cf25 );
\par                 \cb1\cf0 pide_info\cb3\cf25 (\cb1\cf0 buffreg\cb3\cf25 );
\par                 \cb1\cf0 byte_pos \cb3\cf25 = \cb1\cf0 encabezado\cb3\cf25 .\cb1\cf0 cont_reg \cb3\cf25 * \cb1\cf0 LONG_REG \cb3\cf25 + \cb3\cf14\b sizeof\b0\cb3\cf25 (\cb1\cf0 encabezado\cb3\cf25 );
\par                 \cb1\cf0 lseek\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 ,(\cb3\cf14\b long\b0\cb3\cf25 ) \cb1\cf0 byte_pos\cb3\cf25 , \cb3\cf12 0\cb3\cf25 );
\par                 \cb1\cf0 write\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 ,\cb1\cf0 buffreg\cb3\cf25 ,\cb1\cf0 LONG_REG\cb3\cf25 );
\par                 \cb1\cf0 encabezado\cb3\cf25 .\cb1\cf0 cont_reg\cb3\cf25 ++;
\par                 \cb3\cf14\b break\b0\cb3\cf25 ;
\par             \}
\par         \cb3\cf14\b case \b0\cb3\cf12 2\cb3\cf25 :\cb3\cf4 //actualiza un registro existente
\par             \cb3\cf25 \{
\par                 \cb1\cf0 nrr \cb3\cf25 = \cb1\cf0 pide_nrr\cb3\cf25 ();
\par                 \cb3\cf4 //si el NRR es muy grande, imprime mensaje de error
\par                 \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 nrr \cb3\cf25 >= \cb1\cf0 encabezado\cb3\cf25 .\cb1\cf0 cont_reg\cb3\cf25 )
\par                 \{
\par                     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "El numero de registro es demasiado grande"\cb3\cf25 );
\par                     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "...se vuelve al menu..."\cb3\cf25 );
\par                     \cb3\cf14\b break\b0\cb3\cf25 ;
\par                 \}
\par 
\par                 \cb3\cf4 //En caso contrario, se coloca el registro...
\par                 \cb1\cf0 byte_pos \cb3\cf25 = \cb1\cf0 nrr \cb3\cf25 * \cb1\cf0 LONG_REG \cb3\cf25 + \cb3\cf14\b sizeof\b0\cb3\cf25 (\cb1\cf0 encabezado\cb3\cf25 );
\par                 \cb1\cf0 lseek\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 , (\cb3\cf14\b long\b0\cb3\cf25 ) \cb1\cf0 byte_pos\cb3\cf25 , \cb3\cf12 0\cb3\cf25 );
\par 
\par                 \cb3\cf4 //lo despliega y pide cambios
\par                 \cb1\cf0 lee_y_muestra\cb3\cf25 ();
\par                 \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 cambio\cb3\cf25 ())
\par                 \{
\par                     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\n\\n proporcione los valores revisados: \\n\\n"\cb3\cf25 );
\par                     \cb1\cf0 pide_info\cb3\cf25 (\cb1\cf0 buffreg\cb3\cf25 );
\par                     \cb1\cf0 lseek\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 , (\cb3\cf14\b long\b0\cb3\cf25 ) \cb1\cf0 byte_pos\cb3\cf25 , \cb3\cf12 0\cb3\cf25 );
\par                     \cb1\cf0 write\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 ,\cb1\cf0 buffreg\cb3\cf25 ,\cb1\cf0 LONG_REG\cb3\cf25 );
\par                 \}
\par                 \cb3\cf14\b break\b0\cb3\cf25 ;
\par             \}
\par         \}
\par     \}
\par     \cb3\cf4 //reescribe la suma de registros correcta en el encabezado
\par     //antes de terminar
\par     \cb1\cf0 lseek\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 ,\cb3\cf12 0L\cb3\cf25 ,\cb3\cf12 0\cb3\cf25 );
\par     \cb1\cf0 write\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 ,&\cb1\cf0 encabezado\cb3\cf25 ,\cb3\cf14\b sizeof\b0\cb3\cf25 (\cb1\cf0 encabezado\cb3\cf25 ));
\par     \cb1\cf0 close\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 );
\par     \cb3\cf14\b return \b0\cb3\cf12 0\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b int \b0\cb1\cf0 menu\cb3\cf25 ()
\par \{
\par     \cb3\cf14\b int \b0\cb1\cf0 eleccion\cb3\cf25 ;
\par     \cb3\cf14\b char \b0\cb1\cf0 respuesta\cb3\cf25 [\cb3\cf12 10\cb3\cf25 ];
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\n\\n\\n\\n\\t Programa de actualizacion del archivo\\n"\cb3\cf25 );
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\n Encabezado: \\n"\cb3\cf25 );
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "NRR (Registros disponibles): %i\\n"\cb3\cf25 ,\cb1\cf0 encabezado\cb3\cf25 .\cb1\cf0 cont_reg\cb3\cf25 );
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\n\\n Puede elegir: \\n\\n"\cb3\cf25 );
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\n 1) Agregar un registro al final del archivo\\n"\cb3\cf25 );
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\n 2) Extraer un registro para actualizarlo\\n"\cb3\cf25 );
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\n 3) Salir del programa\\n\\n"\cb3\cf25 );
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "Proporcione el numero de su eleccion: "\cb3\cf25 );
\par     \cb1\cf0 gets\cb3\cf25 (\cb1\cf0 respuesta\cb3\cf25 );
\par     \cb1\cf0 eleccion \cb3\cf25 = \cb1\cf0 atoi\cb3\cf25 (\cb1\cf0 respuesta\cb3\cf25 );
\par     \cb3\cf14\b return\b0\cb3\cf25 (\cb1\cf0 eleccion\cb3\cf25 );
\par \};
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 pide_info\cb3\cf25 (\cb3\cf14\b char \b0\cb1\cf0 buffreg\cb3\cf25 [])
\par \{
\par     \cb3\cf14\b char \b0\cb1\cf0 c\cb3\cf25 ;
\par     \cb3\cf14\b int \b0\cb1\cf0 cont_campos\cb3\cf25 , \cb1\cf0 i\cb3\cf25 , \cb1\cf0 nc \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ;
\par     \cb3\cf14\b char \b0\cb1\cf0 respuesta\cb3\cf25 [\cb3\cf12 50\cb3\cf25 ];
\par     \cb3\cf14\b char \b0\cb1\cf0 tiempo\cb3\cf25 [\cb3\cf12 50\cb3\cf25 ];
\par     \cb3\cf4 //limpia el buffer del registro
\par     \cb3\cf14\b for \b0\cb3\cf25 (\cb1\cf0 i \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ; \cb1\cf0 i \cb3\cf25 < \cb1\cf0 LONG_REG\cb3\cf25 ; \cb1\cf0 buffreg\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ++] = \cb3\cf22 '\\0'\cb3\cf25 )
\par         ;
\par     \cb3\cf4 //fflush(stdin);
\par     \cb3\cf14\b for \b0\cb3\cf25 (\cb1\cf0 i \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ; *\cb1\cf0 solicitud\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ] != \cb3\cf22 '\\0'\cb3\cf25 ;\cb1\cf0 i\cb3\cf25 ++)
\par     \{
\par         \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 i \cb3\cf25 == \cb3\cf12 0\cb3\cf25 )
\par         \{
\par             \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "%s"\cb3\cf25 ,\cb1\cf0 solicitud\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]);
\par             \cb1\cf0 gets\cb3\cf25 (\cb1\cf0 respuesta\cb3\cf25 );
\par             \cb1\cf0 campo_a_sin_deli\cb3\cf25 (\cb1\cf0 buffreg\cb3\cf25 ,\cb1\cf0 respuesta\cb3\cf25 );
\par         \}
\par         \cb3\cf14\b else if\b0\cb3\cf25 (\cb1\cf0 i \cb3\cf25 == \cb3\cf12 1\cb3\cf25 )
\par         \{
\par             \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "%s"\cb3\cf25 ,\cb1\cf0 solicitud\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]);
\par                 \cb3\cf14\b while \b0\cb3\cf25 ((\cb1\cf0 c \cb3\cf25 = \cb1\cf0 getchar\cb3\cf25 ()) != \cb3\cf22 '\\n'\cb3\cf25 )
\par                 \{
\par                     \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 c \cb3\cf25 != \cb3\cf22 ' ' \cb3\cf25 && \cb1\cf0 c \cb3\cf25 != \cb3\cf22 ':'\cb3\cf25 )
\par                     \{
\par                         \cb1\cf0 tiempo\cb3\cf25 [\cb1\cf0 nc\cb3\cf25 ] = \cb1\cf0 c\cb3\cf25 ;
\par                         \cb1\cf0 nc\cb3\cf25 ++;
\par                     \}
\par                 \}
\par             \cb1\cf0 campo_a_sin_deli\cb3\cf25 (\cb1\cf0 buffreg\cb3\cf25 ,\cb1\cf0 tiempo\cb3\cf25 );
\par         \}
\par         \cb3\cf14\b else
\par         \b0\cb3\cf25 \{
\par             \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "%s"\cb3\cf25 ,\cb1\cf0 solicitud\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ]);
\par             \cb1\cf0 gets\cb3\cf25 (\cb1\cf0 respuesta\cb3\cf25 );
\par             \cb1\cf0 campo_a_buffreg\cb3\cf25 (\cb1\cf0 buffreg\cb3\cf25 ,\cb1\cf0 respuesta\cb3\cf25 );
\par         \}
\par         \cb1\cf0 cont_campos \cb3\cf25 = \cb1\cf0 LONG_REG \cb3\cf25 - \cb1\cf0 strlen\cb3\cf25 (\cb1\cf0 buffreg\cb3\cf25 );
\par         \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "Te quedan %i caracteres para la info \\n"\cb3\cf25 ,\cb1\cf0 cont_campos\cb3\cf25 );
\par     \}
\par \}
\par 
\par \cb3\cf14\b int \b0\cb1\cf0 pide_nrr\cb3\cf25 ()
\par \{
\par     \cb3\cf14\b int \b0\cb1\cf0 nrr\cb3\cf25 ;
\par     \cb3\cf14\b char \b0\cb1\cf0 respuesta\cb3\cf25 [\cb3\cf12 10\cb3\cf25 ];
\par 
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\n\\n Digite el numero relativo del registro\\n"\cb3\cf25 );
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\t que desee actualizar: "\cb3\cf25 );
\par     \cb1\cf0 gets\cb3\cf25 (\cb1\cf0 respuesta\cb3\cf25 );
\par     \cb1\cf0 nrr \cb3\cf25 = \cb1\cf0 atoi\cb3\cf25 (\cb1\cf0 respuesta\cb3\cf25 );
\par     \cb3\cf14\b return\b0\cb3\cf25 (\cb1\cf0 nrr\cb3\cf25 );
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 lee_y_muestra\cb3\cf25 ()
\par \{
\par     \cb3\cf14\b char \b0\cb1\cf0 buffreg\cb3\cf25 [\cb1\cf0 TAM_MAX_REG \cb3\cf25 + \cb3\cf12 1\cb3\cf25 ], \cb1\cf0 campo\cb3\cf25 [\cb1\cf0 TAM_MAX_REG \cb3\cf25 + \cb3\cf12 1\cb3\cf25 ], \cb1\cf0 otro_campo\cb3\cf25 [\cb1\cf0 TAM_MAX_REG \cb3\cf25 + \cb3\cf12 1\cb3\cf25 ];
\par     \cb3\cf14\b int \b0\cb1\cf0 pos_bus \cb3\cf25 = \cb3\cf12 9\cb3\cf25 , \cb1\cf0 long_datos\cb3\cf25 , \cb1\cf0 i \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ;
\par     \cb1\cf0 read\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 , \cb1\cf0 buffreg\cb3\cf25 , \cb1\cf0 LONG_REG\cb3\cf25 );
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\n\\n\\n\\n Contenido del registro existente\\n"\cb3\cf25 );
\par     \cb1\cf0 buffreg\cb3\cf25 [\cb1\cf0 LONG_REG\cb3\cf25 ] = \cb3\cf22 '\\0'\cb3\cf25 ;\cb3\cf4 //se asegura que el registro termine en nulo
\par     \cb1\cf0 long_datos \cb3\cf25 = \cb1\cf0 strlen\cb3\cf25 (\cb1\cf0 buffreg\cb3\cf25 );
\par         \cb3\cf14\b for \b0\cb3\cf25 (\cb1\cf0 i \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ; \cb1\cf0 i \cb3\cf25 < \cb3\cf12 9\cb3\cf25 ; \cb1\cf0 i\cb3\cf25 ++)
\par         \{
\par             \cb1\cf0 otro_campo\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ] = \cb1\cf0 buffreg\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ];
\par             \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 i \cb3\cf25 == \cb3\cf12 3\cb3\cf25 )
\par             \{
\par                 \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\t%c%c%c%c\\n"\cb3\cf25 ,\cb1\cf0 buffreg\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ],\cb1\cf0 buffreg\cb3\cf25 [\cb3\cf12 1\cb3\cf25 ],\cb1\cf0 buffreg\cb3\cf25 [\cb3\cf12 2\cb3\cf25 ],\cb1\cf0 buffreg\cb3\cf25 [\cb3\cf12 3\cb3\cf25 ]);
\par             \}
\par         \}
\par         \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\t%c"\cb3\cf25 ,\cb1\cf0 buffreg\cb3\cf25 [\cb3\cf12 4\cb3\cf25 ]);
\par         \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 ":"\cb3\cf25 );
\par         \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "%c%c"\cb3\cf25 ,\cb1\cf0 buffreg\cb3\cf25 [\cb3\cf12 5\cb3\cf25 ],\cb1\cf0 buffreg\cb3\cf25 [\cb3\cf12 6\cb3\cf25 ]);
\par         \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 ":"\cb3\cf25 );
\par         \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "%c%c\\n"\cb3\cf25 ,\cb1\cf0 buffreg\cb3\cf25 [\cb3\cf12 7\cb3\cf25 ],\cb1\cf0 buffreg\cb3\cf25 [\cb3\cf12 8\cb3\cf25 ]);
\par 
\par     \cb3\cf14\b while\b0\cb3\cf25 ((\cb1\cf0 pos_bus \cb3\cf25 = \cb1\cf0 toma_campo\cb3\cf25 (\cb1\cf0 campo\cb3\cf25 , \cb1\cf0 buffreg\cb3\cf25 , \cb1\cf0 pos_bus\cb3\cf25 , \cb1\cf0 long_datos\cb3\cf25 )) > \cb3\cf12 0\cb3\cf25 )
\par     \{
\par             \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 pos_bus \cb3\cf25 > \cb3\cf12 9\cb3\cf25 )
\par             \{
\par                 \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\t%s\\n"\cb3\cf25 ,\cb1\cf0 campo\cb3\cf25 );
\par             \}
\par     \}
\par \}
\par 
\par \cb3\cf14\b int \b0\cb1\cf0 cambio\cb3\cf25 ()
\par \{
\par     \cb3\cf14\b char \b0\cb1\cf0 respuesta\cb3\cf25 [\cb3\cf12 10\cb3\cf25 ];
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\n\\n Desea modificar este registro?\\n"\cb3\cf25 );
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "Conteste S o N, seguido por <ENTER> ==>"\cb3\cf25 );
\par     \cb1\cf0 gets\cb3\cf25 (\cb1\cf0 respuesta\cb3\cf25 );
\par     \cb1\cf0 mayusculas\cb3\cf25 (\cb1\cf0 respuesta\cb3\cf25 ,\cb1\cf0 respuesta\cb3\cf25 );
\par     \cb3\cf14\b return\b0\cb3\cf25 ((\cb1\cf0 respuesta\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ] == \cb3\cf22 'S'\cb3\cf25 ) ? \cb3\cf12 1\cb3\cf25 :\cb3\cf12 0\cb3\cf25 );
\par \}
\par }