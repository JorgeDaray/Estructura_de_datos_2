{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue0;\red255\green255\blue255;\red200\green200\blue200;\red0\green0\blue0;\red152\green152\blue217;\red192\green192\blue192;\red128\green128\blue255;\red170\green170\blue240;\red0\green128\blue128;\red107\green153\blue153;\red128\green0\blue0;\red172\green89\blue89;\red240\green0\blue240;\red240\green200\blue240;\red0\green0\blue160;\red135\green135\blue200;\red0\green160\blue0;\red154\green200\blue154;\red190\green0\blue190;\red190\green137\blue190;\red0\green0\blue255;\red190\green190\blue255;\red224\green160\blue0;\red224\green206\blue159;\red132\green160\blue132;\red255\green0\blue0;\red255\green200\blue200;\red64\green64\blue128;\red133\green133\blue172;\red128\green255\blue255;\red55\green55\blue55;}
{\info{\comment Generated by the Code::Blocks RTF Exporter plugin}
{\title Untitled}}

\deflang1033\pard\plain\f0\fs20 \cb3\cf4 /*
\par Alumno: Padilla Perez Jorge Daray
\par Codigo: 216584703
\par Materia: Estructura de datos 2
\par seccion: D09
\par Profesor: Miguel Angel Guerrero Segura Ramirez 
\par */
\par \cb3\cf16 #include <stdio.h>
\par #include <stdlib.h>
\par #include <string.h>
\par #include "arches.h"
\par #define saca_cad(fd, cad)  write((fd), (cad), strlen(cad));\\
\par                                         write ((fd), DELIM_CAD, 1);
\par \cb3\cf4 /* escribesec.c
\par Crea el archivo de nombres y direcciones que es, en forma estricta, una secuencia de bytes
\par (sin delimitadores, contadores, u otra información que ayude a distinguir campos y registros).
\par Una modificación simple a la macro saca_cad:
\par 
\par #define saca_cad (fd, cad) write((fd), (cad),       strlen (cad)); \\
\par 
\par                                                     write ((fd), DELIM CAD, 1);
\par 
\par cambia el programa de tal forma que crea campos delimitados.
\par */
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 ingresar\cb3\cf25 ();
\par \cb3\cf14\b void \b0\cb1\cf0 leer\cb3\cf25 ();
\par \cb3\cf14\b void \b0\cb1\cf0 menu\cb3\cf25 ();
\par 
\par     \cb3\cf14\b char \b0\cb1\cf0 nombre\cb3\cf25 [\cb3\cf12 30\cb3\cf25 ], \cb1\cf0 direccion\cb3\cf25 [\cb3\cf12 30\cb3\cf25 ], \cb1\cf0 ciudad\cb3\cf25 [\cb3\cf12 20\cb3\cf25 ];
\par     \cb3\cf14\b char \b0\cb1\cf0 estado\cb3\cf25 [\cb3\cf12 15\cb3\cf25 ], \cb1\cf0 cp\cb3\cf25 [\cb3\cf12 9\cb3\cf25 ], \cb1\cf0 ramo\cb3\cf25 [\cb3\cf12 30\cb3\cf25 ];
\par     \cb3\cf14\b char \b0\cb1\cf0 nomarch \cb3\cf25 [\cb3\cf12 15\cb3\cf25 ];\cb3\cf4 //Declaracion archivo fisico.
\par     \cb3\cf14\b int \b0\cb1\cf0 fd\cb3\cf25 ;\cb3\cf4 //Declaracion archivo logico.
\par 
\par \cb3\cf14\b int \b0\cb1\cf0 main\cb3\cf25 ()
\par \{
\par     \cb3\cf14\b int \b0\cb1\cf0 opc \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ;
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "Proporcione el nombre del archivo que quiera crear o leer: "\cb3\cf25 );
\par     \cb1\cf0 gets \cb3\cf25 (\cb1\cf0 nomarch\cb3\cf25 );\cb3\cf4 //Obtencion del nombre del archivo fisico.
\par     \cb3\cf14\b if \b0\cb3\cf25 ((\cb1\cf0 fd \cb3\cf25 = \cb1\cf0 open\cb3\cf25 (\cb1\cf0 nomarch\cb3\cf25 ,\cb1\cf0 LECTESCRIT\cb3\cf25 )) < \cb3\cf12 0\cb3\cf25 )\cb3\cf4 //Apertura de archivo fisico, a traves del archivo logico. Escritura y Lectura.
\par     \cb3\cf25 \{
\par         \cb1\cf0 fd \cb3\cf25 = \cb1\cf0 creat\cb3\cf25 (\cb1\cf0 nomarch\cb3\cf25 ,\cb1\cf0 PMODE\cb3\cf25 );\cb3\cf4 //Creacion del archivo fisico, a traves del archivo logico. En PMODE 0755.
\par         \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "Creado correctamente\\n"\cb3\cf25 );
\par         \cb1\cf0 system\cb3\cf25 (\cb3\cf20 "pause"\cb3\cf25 );
\par     \}
\par     \cb3\cf14\b while \b0\cb3\cf25 (\cb1\cf0 opc\cb3\cf25 !=\cb3\cf12 3\cb3\cf25 )
\par     \{
\par         \cb1\cf0 system\cb3\cf25 (\cb3\cf20 "cls"\cb3\cf25 );
\par         \cb1\cf0 menu\cb3\cf25 ();
\par         \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "Continuar 1 salir 3:\\n"\cb3\cf25 );\cb1\cf0 scanf\cb3\cf25 (\cb3\cf20 "%d"\cb3\cf25 , &\cb1\cf0 opc\cb3\cf25 );
\par    \}
\par     \cb3\cf14\b return \b0\cb3\cf12 0\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 ingresar\cb3\cf25 ()
\par \{
\par     \cb1\cf0 fflush\cb3\cf25 (\cb1\cf0 stdin\cb3\cf25 );
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\n\\nDigite un nombre o razon social del cliente, o <CR> para salir\\n>>>"\cb3\cf25 );
\par     \cb1\cf0 gets \cb3\cf25 (\cb1\cf0 nombre\cb3\cf25 );
\par     \cb3\cf14\b while \b0\cb3\cf25 (\cb1\cf0 strlen\cb3\cf25 (\cb1\cf0 nombre\cb3\cf25 ) > \cb3\cf12 0\cb3\cf25 )
\par     \{
\par         \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 " Dirección de la empresa:"\cb3\cf25 );
\par         \cb1\cf0 gets \cb3\cf25 (\cb1\cf0 direccion\cb3\cf25 );
\par 
\par         \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 " ciudad:"\cb3\cf25 );
\par         \cb1\cf0 gets \cb3\cf25 (\cb1\cf0 ciudad\cb3\cf25 );
\par 
\par         \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 " Estado:"\cb3\cf25 );
\par         \cb1\cf0 gets\cb3\cf25 (\cb1\cf0 estado\cb3\cf25 );
\par 
\par         \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 " Cod. Post.:"\cb3\cf25 );
\par         \cb1\cf0 gets \cb3\cf25 (\cb1\cf0 cp\cb3\cf25 );
\par 
\par         \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 " Ramo a que se dedica:"\cb3\cf25 );
\par         \cb1\cf0 gets \cb3\cf25 (\cb1\cf0 ramo\cb3\cf25 );
\par 
\par     \cb1\cf0 lseek\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 ,\cb3\cf12 0L\cb3\cf25 ,\cb3\cf12 2\cb3\cf25 );\cb3\cf4 //Traslada el puntero al final del archivo, para no sobreescribir.
\par     \cb3\cf4 /* Traslada las cadenas al buffer y después al archivo */
\par 
\par         \cb1\cf0 saca_cad \cb3\cf25 (\cb1\cf0 fd\cb3\cf25 , \cb1\cf0 nombre\cb3\cf25 );
\par         \cb1\cf0 saca_cad \cb3\cf25 (\cb1\cf0 fd\cb3\cf25 , \cb1\cf0 direccion\cb3\cf25 );
\par         \cb1\cf0 saca_cad \cb3\cf25 (\cb1\cf0 fd\cb3\cf25 , \cb1\cf0 ciudad\cb3\cf25 );
\par         \cb1\cf0 saca_cad \cb3\cf25 (\cb1\cf0 fd\cb3\cf25 , \cb1\cf0 estado\cb3\cf25 );
\par         \cb1\cf0 saca_cad \cb3\cf25 (\cb1\cf0 fd\cb3\cf25 , \cb1\cf0 cp\cb3\cf25 );
\par         \cb1\cf0 saca_cad \cb3\cf25 (\cb1\cf0 fd\cb3\cf25 , \cb1\cf0 ramo\cb3\cf25 );
\par     \cb3\cf4 /* se prepara para los siguientes datos */
\par 
\par     \cb1\cf0 system\cb3\cf25 (\cb3\cf20 "pause"\cb3\cf25 );
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\n\\nDigite un nombre o razon social del cliente, o <CR> para salir\\n>>>"\cb3\cf25 );
\par     \cb1\cf0 gets \cb3\cf25 (\cb1\cf0 nombre\cb3\cf25 );
\par     \}
\par \}
\par 
\par 
\par \cb3\cf4 /*
\par leesec.c
\par lee una secuencia de campos delimitados
\par */
\par \cb3\cf14\b void \b0\cb1\cf0 leer\cb3\cf25 ()
\par \{
\par     \cb3\cf14\b int \b0\cb1\cf0 n\cb3\cf25 ;
\par     \cb3\cf14\b char \b0\cb1\cf0 cad\cb3\cf25 [\cb3\cf12 30\cb3\cf25 ];
\par     \cb3\cf14\b int \b0\cb1\cf0 cont_campos\cb3\cf25 ;
\par 
\par     \cb3\cf4 /* Ciclo del programa principal llama a leecampo () hasta que se leen todos los campos */
\par 
\par     \cb1\cf0 cont_campos \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ;
\par     \cb1\cf0 lseek\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 ,\cb3\cf12 0L\cb3\cf25 ,\cb3\cf12 0\cb3\cf25 );\cb3\cf4 //Traslada el puntero al inicio.
\par     \cb3\cf14\b while \b0\cb3\cf25 ((\cb1\cf0 n \cb3\cf25 = \cb1\cf0 leecampo\cb3\cf25 (\cb1\cf0 fd\cb3\cf25 , \cb1\cf0 cad\cb3\cf25 )) > \cb3\cf12 0\cb3\cf25 )
\par         \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "\\tCampo # %3d: %s\\n"\cb3\cf25 , ++\cb1\cf0 cont_campos\cb3\cf25 , \cb1\cf0 cad\cb3\cf25 );
\par \}
\par 
\par \cb1\cf0 leecampo\cb3\cf25 (\cb3\cf14\b int \b0\cb1\cf0 fd\cb3\cf25 ,\cb3\cf14\b char \b0\cb1\cf0 cad\cb3\cf25 [])
\par \{
\par     \cb3\cf14\b int \b0\cb1\cf0 i\cb3\cf25 ;
\par     \cb3\cf14\b char \b0\cb1\cf0 c\cb3\cf25 ;
\par     \cb1\cf0 i \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ;
\par 
\par     \cb3\cf14\b while \b0\cb3\cf25 (\cb1\cf0 read \cb3\cf25 (\cb1\cf0 fd\cb3\cf25 , &\cb1\cf0 c\cb3\cf25 , \cb3\cf12 1\cb3\cf25 ) > \cb3\cf12 0 \cb3\cf25 && \cb1\cf0 c \cb3\cf25 != \cb1\cf0 DELIM_CAR\cb3\cf25 )
\par     \cb1\cf0 cad\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ++] = \cb1\cf0 c\cb3\cf25 ;
\par 
\par     \cb1\cf0 cad\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ] = \cb3\cf22 '\\0'\cb3\cf25 ; \cb3\cf4 /*Agrega un caracter nulo al final de la cadena*/
\par     \cb3\cf14\b return \b0\cb3\cf25 (\cb1\cf0 i\cb3\cf25 );
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 menu\cb3\cf25 ()
\par \{
\par     \cb3\cf14\b int \b0\cb1\cf0 opc \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ;
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "1) Ingresar cliente\\n"\cb3\cf25 );
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "2) Leer cliente\\n"\cb3\cf25 );
\par     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "3) Salir\\n"\cb3\cf25 );
\par     \cb1\cf0 scanf\cb3\cf25 (\cb3\cf20 "%d"\cb3\cf25 , &\cb1\cf0 opc\cb3\cf25 );
\par     \cb3\cf14\b switch\b0\cb3\cf25 (\cb1\cf0 opc\cb3\cf25 )\{
\par 
\par         \cb3\cf14\b case \b0\cb3\cf12 1\cb3\cf25 : \{
\par                     \cb1\cf0 ingresar\cb3\cf25 ();
\par                 \}\cb3\cf14\b break\b0\cb3\cf25 ;
\par         \cb3\cf14\b case \b0\cb3\cf12 2\cb3\cf25 : \{
\par                     \cb1\cf0 leer\cb3\cf25 ();
\par                 \}\cb3\cf14\b break\b0\cb3\cf25 ;
\par         \cb3\cf14\b case \b0\cb3\cf12 3\cb3\cf25 : \{
\par                     \cb1\cf0 printf\cb3\cf25 (\cb3\cf20 "Saliendo\\n"\cb3\cf25 );
\par                      \cb1\cf0 close \cb3\cf25 (\cb1\cf0 fd\cb3\cf25 );\cb3\cf4 //Cierre del archivo.
\par                 \cb3\cf25 \}\cb3\cf14\b break\b0\cb3\cf25 ;
\par     \}
\par \}
\par }